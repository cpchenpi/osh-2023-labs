# Lab2 实验记录
> PB21000039 陈骆鑫

## 1.目录导航

### `pwd`命令

查阅资料，可知linux下有多个返回当前工作目录的系统调用，我选择了`get_current_dir_name`。它无需传入参数，会`malloc`一块内存以返回数据；我们只要在输出后将其`free`即可。

### `cd`命令

经过测试，`chdir`系统调用支持`./`、`../`等格式，但不支持Bash支持的`~/`。因此，调用之前，我们应判断第一个字符是否为`~`，并将其替换为家目录。同时，Bash在`cd`无参数时会进入到家目录，对`args`的大小特判即可实现。家目录，即`HOME`环境变量，可以通过`getenv`获取（我们认为家目录不会随便更改，因此只在进入程序时读取一次）。

## 2.管道

### 实现

我们需要实现任意多条命令之间的管道。

考虑一般的合理情况。此时，有由`"|"`分隔的`n`条命令，那么要打开`n-1`条管道，第`i`条管道连接第`i`与`i+1`条命令。

管道可以由`pipe`函数创建，之后可以通过`dup2`函数将标准输入/输出重定向到管道的一端。

实现的思路很简洁，但实际上实现并不算简单。为了方便，我们选择了递归的实现方式：
- 先根据`"|"`将命令分割为多条，填充到命令队列中；之后每次递归从队列中取出一条命令，启动它的执行，并在队列中仍剩余命令时打开一个管道。
- 我们让同一个进程执行这一递归，并在每次递归中创建一个新进程，执行任务。注意执行任务需要知道它前后的管道，因此递归函数需要一个传递前一个管道的参数。
- 创建子进程会继承父进程所有的文件描述符，`dup2`也不会关闭原来的文件描述符；而为了确保完成任务，所有用不到的文件描述符需要立即关闭。因此，需要关闭的文件如下：
  - 在创建子进程后，父进程要立即关闭管道；
  - 在`dup2`之后，子进程要立即关闭管道。

## 3.重定向

### 实现

考虑实际情景下的合理操作：我们只会在管道的最开始重定向输入，在管道的末尾重定向输出。因此，我们选择在运行单个任务部分添加处理逻辑。同时，对“数字+符号”的判断相对较复杂，故我们实现了`>`、`>>`、`<`、`<<`、`<<<`五种重定向方式。
实现逻辑如下：
- 如果没有左侧的管道，检测最后两个单词是否为输入重定向。如果是，删除最后两个单词，并执行对应重定向。
  - `<`：用`open`打开对应文件，并用`dup2`重定向到输入。
  - `<<`：用`open`创建一个临时文件，在输入行不是对应符号的情况下不断填充文件；最后将读写指针定位到开头，并用`dup2`重定向到输入。
  - `<`：用`open`创建一个临时文件，输入最后一个单词；最后将读写指针定位到开头，并用`dup2`重定向到输入。
- 如果没有右侧的管道，检测最后两个单词是否为输出重定向。如果是，删除最后两个单词，并执行对应重定向。
  - `<`/`<<`：用`open`以对应模式打开对应文件，并用`dup2`重定向到输出。
- **注意**：可以看到这样的实现方式有一定的局限性：重定向必须位于最后。而经过测试，Bash似乎使用词法分析的方式来解析`>`运算符和其参数。

## 4.信号处理

### 实现

由于我们由一个fork出的子进程再fork出所有执行命令的进程，只需要把一开始的子进程分离进程组即可。在分离进程组之后，要立即把前台交给该进程组；在所有执行任务的子进程结束后，把权限交还给shell主程序。这样就能确保程序执行时，shell主程序不会收到`SIGINT`信号。此时，我们就可以直接把主程序的SIGINT信号处理修改为丢弃命令。

注意到第一个fork出的子进程只是辅助进程，负责执行任务进程的启动和等待其退出、交还控制权，为了确保控制权被成功交还，可以让其忽略`SIGINT`信号。所有执行任务的子进程应该切换会默认信号处理程序。

在实现过程中遇到了很多问题，最后发现问题在于有些操作不应该立即执行，而应该等待一些前置条件完成后进行。例如，shell启动时应等待自己成为前台进程；shell应该在进程组分离完成后才把前台交给该进程组。

**注意**：结合前面的代码结构，这个实现方式会导致内建命令无法终止（而且一般来说中止内建命令可能会导致程序处在未预料的状态，可能不安全）。一般来说这没有影响，但对后面wait会有较大的影响。（我觉得wait在执行中途被截断也可能造成不安全的状态……）

## 5.后台进程

### 实现

在实现信号处理章节内容后，实现该部分容易了许多。我们只要在结尾有&时修改一部分逻辑：无需把前台交给进程组，也无需等待子进程结束；只需要把进程PID保存到一个队列中，在`wait`命令时依次等待即可。

## 6.选做部分

### 支持history

用一个`vector`记录所有命令即可。注意bash的`history`可以显示打开bash，甚至开机之前的历史，这是因为它用文件记录了历史；为了方便我们就不再做持久化的工作了。对于`!!`和`!n`，观察bash的处理方式，应该在命令的解析阶段直接完成替换。

**注意**：观察bash的处理方式，实际上不会重复记录连续两条相同的命令。我们认为这是无关紧要的细节，就忠实地记录了每一条完成`!*`的解析的命令。

**注意**：实际上在实验简介中也提到了GNU Readline这个库。若使用这个库，历史支持甚至第二点选做（上下方向键）都可以很容易地实现。但我认为但就这一个功能，使用这个库或多或少有点“作弊”，而且也避免进行较大的重构，因此选择了现在的方案。

### 支持alias

观察bash的行为，应当仅对参数的第一个单词做替换。考虑用C++中的字典数据结构实现。

**注意**：为了避免复杂的词法分析，采用与bash不同的处理方式：使用"="分割两边，两边分别视为别名和原名。例如`alias ll = ls -l`，而不是`alias ll='ls-l'`。若没有等号（只有一个参数），即为查询别名的原名，例如`alias ll`在执行前面的命令之后会返回其原名。若无参数，返回所有别名及其原名。
**注意**：与history类似，为了方便也没有做持久化。

#### 完成内容归档

- 所有必做内容
- 选做内容：
  - cd默认进入家目录
  - 文本重定向
  - EOF重定向
  - history命令
  - alias命令